# Polog - ультимативный логгер для баз данных

Используйте преимущества базы данных для логгирования в ваших проектах! Легко ищите нужные вам логи, составляйте статистику и управляйте ими при помощи SQL.

Данный пакет максимально упростит миграцию ваших логов в базу данных. Вот список некоторых преимуществ логгера Polog:

- Автоматическое логгирование. Просто повесьте декоратор на вашу функцию или класс, и каждый их вызов будет автоматически логгироваться в базу данных (или не каждый - это легко настроить)!
- Высокая производительность. Непосредственно сама запись в базу делается из отдельных потоков и не блокирует основной поток исполнения вашей программы.
- Поддержка асинхронных функций. Декораторы для автоматического логгирования работают как на синхронных, так и на асинхронных функциях.
- Самый простой синтаксис. Сделать логгирование еще проще уже вряд ли возможно. Вы можете залоггировать целый класс всего одной строчкой кода. Имена функций короткие, насколько это позволяет здравый смысл.
- Удобное профилирование. В базу автоматически записывается время работы ваших функций. Так вы можете накопить статистику производительности вашего кода и легко ее анализировать.

## Быстрый старт

Просто импортируйте декоратор @flog() и примените его к вашей функции. Никаких настроек, ничего лишнего - все уже работает.

```
from polog.flog import flog


@flog()
def sum(a, b):
  return a + b

print(sum(2, 2))
```

На этом примере при первом вызове вашей функции sum в папке с вашим проектом будет автоматически создан файл с базой данных sqlite, в которой появится соответствующая запись. В данном случае сохранится информация о том, какая функция была вызвана, из какого она модуля, с какими аргументами, сколько времени заняла ее работа и какой результат она вернула.

```
from polog.flog import flog


@flog()
def division(a, b):
  return a / b

print(division(2, 0))
```

Произошла ошибка, мы делим число на 0. Что на этот раз записано в базу? Очевидно, что результат работы функции в базу записан не будет, т.к. она не успела ничего вернуть. Зато там появилась подробная информация об ошибке: название вызванного исключения, текст его сообщения, и главное, трейсбек. Кроме того, появится отметка о неуспешности выполненной операции - ко всем автоматическим логам такие метки проставляются автоматически, чтобы вы могли легко выбирать из базы данных только успешные или только неуспешные операции и как-то анализировать результат.

```
from polog.flog import flog


@flog()
def division(a, b):
  return a / b

@flog()
def operation(a, b):
  return division(a, b)

print(operation(2, 0))
```

Чего примечательного в этом примере кода? В данном случае ошибка происходит в функции division(), а затем, поднимаясь по стеку вызовов, она проходит через функцию operation(). Однако логгер записал в базу данных сообщение об ошибке только один раз! Встретив исключение в первый раз, он пишет его в базу и подменяет другим, специальным, которое игнорирует в дальнейшем. В результате ваша база данных не засоряется бесконечным дублированием информации об ошибках.

На случай, если ваш код специфически реагирует на конкретные типы исключений и вы не хотите, чтобы логгер исключал дублирование логов таким образом, его поведение можно изменить, об этом вы можете прочитать в более подробной части документации ниже.

```
from polog.clog import clog


@clog()
class OneOperation(object):
  def division(self, a, b):
    return a / b

  def operation(self, a, b):
    return self.division(a, b)

print(OneOperation().operation(2, 0))
```

Что, если мы хотим залоггировать целый класс? Обязательно ли проходиться по всем его методам и на каждый вешать декоратор @flog()? Нет! Для классов существует декоратор @clog(). Что он делает? Он за вас проходится по методам класса и вешает на каждый из них декоратор @flog(). Если вы не хотите логгировать ВСЕ методы класса, передайте в @clog() имена методов, которые вам нужно залоггировать, например: @clog('division').

```
from polog.log import log


log(message="All right!")
log(message="It's bad.", success=False, exception=ValueError("Example of an exception."))
```

Если вам все же не хватило автоматического логгирования, вы можете писать логи вручную, вызывая функцию log() из своего кода.

На этом введение закончено. Если вам интересны тонкости настройки логгера и его более мощные функции, можете почитать более подробную документацию.

## Подробности

Начнем с общей информации о логгере. Запись в базу данных происходит из отдельных потоков. Ваша программа "выплевывает" логи в очередь, откуда их считывают воркеры в отдельных потоках. Непосредственно запись в БД происходит в момент, когда ваша программа уже продолжает делать что-то другое. Количество потоков, которые пишут в БД, можно настроить, по умолчанию оно равно 2-м.

Таблица, в которую происходит запись, выглядит так:


id = PrimaryKey(int, auto=True)
function = Optional(str)
module = Optional(str)
message = Optional(str)
exception_type = Optional(str)
exception = Optional(str)
traceback = Optional(str)
input_variables = Optional(str)
result = Optional(str)
success = Optional(bool)
time = Required(datetime.datetime)
time_of_work = Optional(float)
service = Optional(str)
auto = Required(bool)
level = Required(int)

| id | function | module | message | exception_type | exception | traceback | input_variables | result | success | time | time_of_work | service | auto | level |
| -- | -------- | ------ | ------- | -------------- | --------- | --------- | --------------- | ------ | ------- | ---- | ------------ | ------- | ---- | ----- |
| int | str | str | str | str | str | str | str | str | bool | datetime | float | str | bool | int |
| -- | -------- | ------ | ------- | -------------- | --------- | --------- | --------------- | ------ | ------- | ---- | ------------ | ------- | ---- | ----- |

### Уровни логгирования

Каждая запись в базе данных сопровождается це
